//
//  testMessageParser.cpp
//  editest
//
//  Created by 徐雷 on 2020/8/7.
//  Copyright © 2020 MailCore. All rights reserved.
//

#include "ediunittest.h"
#include <dirent.h>
#include <math.h>
#include <time.h>
#include <string>
#include <sstream>

#include "testMessageParser.h"

using namespace mailcore;


static time_t referenceDate(void)
{
    struct tm aTm;
    memset(&aTm, 0, sizeof(aTm));
    aTm.tm_sec = 0;
    aTm.tm_min = 0;
    aTm.tm_hour = 16;
    aTm.tm_mday = 31;
    aTm.tm_mon = 11;
    aTm.tm_year = 2000 - 1900;
    time_t date = mktime(&aTm);
    return date;
}

static Array * pathsInDirectory(String * directory) {
    Array * result = Array::array();

    DIR * dir = opendir(directory->fileSystemRepresentation());
    if (dir == NULL) {
        return result;
    }

    struct dirent * ent;
    while ((ent = readdir(dir)) != NULL) {
        if (ent->d_name[0] == '.') {
            continue;
        }

        String * subpath = directory->stringByAppendingPathComponent(String::stringWithFileSystemRepresentation(ent->d_name));
        if (ent->d_type == DT_DIR) {
            result->addObjectsFromArray(pathsInDirectory(subpath));
        }
        else {
            result->addObject(subpath);
        }
    }
    closedir(dir);

    return result;
}

static void prepareHeaderForUnitTest(MessageHeader * header) {
    time_t now = time(NULL);
    if (fabs((double) (now - header->date())) <= 2) {
        // Date might be generated, set to known date.
        header->setDate(referenceDate());
    }
    if (fabs((double) (header->receivedDate() - now)) <= 2) {
        // Date might be generated, set to known date.
        header->setReceivedDate(referenceDate());
    }
    if (header->isMessageIDAutoGenerated()) {
        header->setMessageID(MCSTR("MyMessageID123@mail.gmail.com"));
    }
}

static void preparePartForUnitTest(AbstractPart * part) {
    if (part->className()->isEqual(MCSTR("mailcore::Multipart"))) {
        Multipart * multipart = (Multipart *) part;
        for(unsigned int i = 0 ; i < multipart->parts()->count() ; i ++) {
            preparePartForUnitTest((AbstractPart *) multipart->parts()->objectAtIndex(i));
        }
    }
    else if (part->className()->isEqual(MCSTR("mailcore::MessagePart"))) {
        prepareHeaderForUnitTest(((MessagePart *) part)->header());
        preparePartForUnitTest(((MessagePart *) part)->mainPart());
    }
}

static testEdiContact convertAddress(mailcore::Address * address) {
    testEdiContact ediCon;
    ediCon.email = address->mailbox()->UTF8Characters();
    
    mailcore::String * dispName = address->displayName();
    if (dispName) {
        ediCon.name = dispName->UTF8Characters();;
    }
    
    return ediCon;
}
void testMessageParser::parseMessageHeader(mailcore::MessageHeader* header, testEdiMessage * message){
    mailcore::String * subject = header->subject();
    if (subject) {
        message->subject = subject->UTF8Characters();
    }
    
    mailcore::String * messageID = header->messageID();
    if (messageID) {
        message->headerMessageId = messageID->UTF8Characters();
    }
    message->date = header->date();
    message->receivedDate = header->receivedDate();

    mailcore::Address * from = header->from();
    if (from) {
        message->from = convertAddress(from);
    }

    mailcore::Address * sender = header->sender();
    if (sender) {
        message->sender = convertAddress(sender);
    }


    mailcore::Array * to = header->to();
    if (to) {
        for (int i = 0; i  < to->count(); i++) {
            mailcore::Address* item =  (mailcore::Address*)to->objectAtIndex(i);
            message->to.push_back(convertAddress(item));
        }
    }

    mailcore::Array * cc = header->cc();
    if (cc) {
        for (int i = 0; i  < cc->count(); i++) {
            mailcore::Address* item =  (mailcore::Address*)cc->objectAtIndex(i);
            message->cc.push_back(convertAddress(item));
        }
    }

    mailcore::Array * bcc = header->bcc();
    if (bcc) {
        for (int i = 0; i  < bcc->count(); i++) {
            mailcore::Address* item =  (mailcore::Address*)bcc->objectAtIndex(i);
            message->bcc.push_back(convertAddress(item));
        }
    }
    mailcore::Array * replyto = header->replyTo();
    if (replyto) {
        for (int i = 0; i  < replyto->count(); i++) {
            mailcore::Address* item =  (mailcore::Address*)replyto->objectAtIndex(i);
            message->replyTo.push_back(convertAddress(item));
        }
    }


    mailcore::Array * inreplyto = header->inReplyTo();
    if (inreplyto != NULL) {
        if (inreplyto->count() > 0) {
            mailcore::String* mstr =  (mailcore::String*)inreplyto->objectAtIndex(0);
            const char * str = mstr->UTF8Characters();
            message->inReplyTo.emplace_back(str);
            message->replyToHeaderMessageId = str;
        }
    }
    //message->replyToHeaderMessageId = "";

    mailcore::Array * references = header->references();
    if (references != NULL) {
        for (int i = 0; i  < references->count(); i++) {
            mailcore::String* item =  (mailcore::String*)references->objectAtIndex(i);
            const char * ref = item->UTF8Characters();
            message->references.emplace_back(ref);
        }
    }

    mailcore::String * hkey = mailcore::String::uniquedStringWithUTF8Characters("List-Unsubscribe");
    mailcore::String * unsubscribe = header->extraHeaderValueForName(hkey);
    if (unsubscribe) {
        const char * listUnsubscribe = unsubscribe->UTF8Characters();
        message->listUnsubscribe = listUnsubscribe;
    }

    mailcore::String * hkeyListId = mailcore::String::uniquedStringWithUTF8Characters("List-ID");
    mailcore::String * listId = header->extraHeaderValueForName(hkeyListId);
    if (listId) {
        const char * listIdStr = listId->UTF8Characters();
        message->listId = listIdStr;
    }

#if CHECK_EMAIL_SECURITY
    mailcore::String * ARKey = mailcore::String::uniquedStringWithUTF8Characters(AUTHENTICATION_RESULTS);
    mailcore::String * ARVal = header->extraHeaderValueForName(ARKey);
    if (ARVal) {
        const char * ARStr = ARVal->UTF8Characters();
        if (ARStr) {
            message->authResults = ARStr;
        }
    }

    mailcore::String * DSKey = mailcore::String::uniquedStringWithUTF8Characters(DKIM_SIGNATURE);
    mailcore::String * DSVal = header->extraHeaderValueForName(DSKey);
    if (DSVal) {
        const char * DSStr = DSVal->UTF8Characters();
        if (DSStr) {
            message->DKIMSign = DSStr;
        }
    }
#endif

#if (CHECK_EMAIL_SECURITY || ZENDESK_CATEGORY_SUPPORTED)
    mailcore::String * RPKey = mailcore::String::uniquedStringWithUTF8Characters(RETURN_PATH);
    mailcore::String * RPVal = header->extraHeaderValueForName(RPKey);
    if (RPVal) {
        const char * RPStr = RPVal->UTF8Characters();
        if (RPStr) {
            message->returnPath = RPStr;
        }
    }
#endif

#if USE_X_EDISON_ID
    mailcore::String * xEdisonIdKey = mailcore::String::uniquedStringWithUTF8Characters(X_EDISON_ID);
    mailcore::String * xEdisonIdVal = header->extraHeaderValueForName(xEdisonIdKey);
    if (xEdisonIdVal) {
        const char * value = xEdisonIdVal->UTF8Characters();
        if (value) {
            message->xEdisonId = value;
        }
    }
#endif
}

/****************************************************************************************************************
 int bodyType;              //0: not body part;         1: plain body part;      2: html body part
 int attachmentType;    //0: not attachment;      1: inline attachment;   2: real attachment
 TODO : duplicate copies in the list
 ***************************************************************************************************************/
static void addSinglePart(testEdiMessage* message, int index, mailcore::AbstractPart * part, int bodyType, int attachmentType) {
    if (nullptr == message || nullptr == part) {
        return;
    }

    if (nullptr == part->partID()) {
        return;
    }

    const char * partId = part->partID()->UTF8Characters();
    testEdiAttachment * attachment = new testEdiAttachment();
    attachment->messageId = message->pId;
    attachment->partId = std::string(partId);
    attachment->pId = message->pId + std::string(partId);
    attachment->mimeType = part->mimeType() ? part->mimeType()->UTF8Characters(): "";
    attachment->partType = part->partType();
    attachment->transferEncoding = part->encoding();

    attachment->charset = part->charset() ? part->charset()->UTF8Characters() : "";
    attachment->uniqueId = part->uniqueID() ? part->uniqueID()->UTF8Characters() : "";
    attachment->contentId = part->contentID() ? part->contentID()->UTF8Characters() : "";
    attachment->bodyType = bodyType;
    attachment->attachmentType = attachmentType;
    
    mailcore::String * filename = part->filename();
    if (filename) {
        mailcore::String * fn = filename->lastPathComponent();
        if (fn) {
            attachment->filename = fn->UTF8Characters();
        }
    }
    attachment->mimeType.compare(0, 5, "text/");
    
    if ( (attachmentType == 1 && attachment->contentId.empty()) ||
         (bodyType == 2 && !attachment->mimeType.compare(0, 5, "text/"))) {
        char Cid[100];
        sprintf(Cid, "U%dP%s", message->uid, partId);
        attachment->contentId = Cid;
    }
    
    if (attachmentType != 0) {
        if (attachment->filename.empty()) {
            std::string newName = "unknown.dat";
            attachment->filename = newName;
        }
    }

#if _MSC_VER
    if (!attachment->filename.empty()) {
        attachment->filename = EdiFileUtils::unifyFilename(attachment->filename);
    }
#endif

    attachment->size = part->size();
    if (attachment->size == 0L) {
        attachment->size = message->size;
    }

    if (!message->hasCalendar) {
        attachment->mimeType.compare(0, strlen("application/calendar"), "application/calendar");
        if (attachment->mimeType.compare(0, strlen("text/calendar"), "text/calendar")==0 || attachment->mimeType.compare(0, strlen("application/calendar"), "application/calendar") == 0) {
            message->hasCalendar = true;
        }
    }
    //attachment->isRfc822MsgPart = EdiStringUtils::iequal(attachment->mimeType.c_str(), "message/rfc822");
    attachment->index = index;
    if (attachmentType == 1 || attachmentType == 2) {
        message->attachmentCount += 1;
    }
    attachment->state = 0;
    
    std::shared_ptr<testEdiAttachment> attachptr(attachment);
    message->attachmentList.push_back(attachptr);
}
void testMessageParser::parseIMAPMessageFromServer(mailcore::IMAPMessage * imapMessage) {
    
    uint32_t uid = imapMessage->uid();

    uint64_t gmailMessageId = imapMessage->gmailMessageID();

    if (gmailMessageId > 0) {
        std::string messageId = std::to_string(gmailMessageId);
    }
    uint64_t gmailThreadId = imapMessage->gmailThreadID();
    if (gmailThreadId > 0) {
        std::string threadId = std::to_string(gmailThreadId);
    }

    mailcore::MessageHeader* header = (mailcore::MessageHeader*)imapMessage->header();
    EXPECT_FALSE(header == NULL);

    if (imapMessage->mainPart()) {
        mailcore::Array * htmlParts = mailcore::Array::array();
        mailcore::Array * plainParts = mailcore::Array::array();
        //Note: we can using ONLY one array, indetify them by attachment->isInline & attachment->isAttachment.
        mailcore::Array * attachmentParts = mailcore::Array::array();
        mailcore::Array * inlineAttachmentParts = mailcore::Array::array();
        mailcore::IMAPPartParser::parseMessage(imapMessage, htmlParts, plainParts, attachmentParts, inlineAttachmentParts);
        int index = 0;
        for (int i = 0; i  < htmlParts->count(); i++) {
            mailcore::AbstractPart * part = (mailcore::AbstractPart*)htmlParts->objectAtIndex(i);

        }
        for (int i = 0; i  < plainParts->count(); i++) {
            mailcore::AbstractPart * part = (mailcore::AbstractPart*)plainParts->objectAtIndex(i);

        }
        for (int i = 0; i  < attachmentParts->count(); i++) {
            mailcore::AbstractPart * part = (mailcore::AbstractPart*)attachmentParts->objectAtIndex(i);

        }
        for (int i = 0; i  < inlineAttachmentParts->count(); i++) {
            mailcore::AbstractPart * part = (mailcore::AbstractPart*)inlineAttachmentParts->objectAtIndex(i);

        }
        // The following lines are just for testing.
        mailcore::Array * bentchmark1 = mailcore::HTMLRenderer::attachmentsForMessage(imapMessage);
        mailcore::Array * bentchmark2 = mailcore::HTMLRenderer::htmlInlineAttachmentsForMessage(imapMessage);
        mailcore::Array * bentchmark3 =mailcore::HTMLRenderer::requiredPartsForRendering(imapMessage);

    }
    return;
}

testEdiMessage * testMessageParser::parseIMAPMessage(mailcore::IMAPMessage * imapMessage) {
    
    uint32_t uid = imapMessage->uid();

    testEdiMessage * message = new testEdiMessage();
    uint64_t gmailMessageId = imapMessage->gmailMessageID();
//    message->folderId = folder->pId;
//    message->folderPath = folder->path;

    if (gmailMessageId > 0) {
        message->messageId = std::to_string(gmailMessageId);
    }
    uint64_t gmailThreadId = imapMessage->gmailThreadID();
    if (gmailThreadId > 0) {
        message->threadId = std::to_string(gmailThreadId);
    }

    mailcore::MessageHeader* header = (mailcore::MessageHeader*)imapMessage->header();
    if (header) {
        testMessageParser::parseMessageHeader(header, message);
    }

//    //set message flag
    message->setFlags(imapMessage->flags());
//
//    //parse gmail label
//    parseGmailLabel(account, folder, imapMessage, message);

    message->size = imapMessage->size();
    
//    setSentFlag(account, folder, message);
//    setDraftFlag(account, folder, message);
    
    message->inAllMail = true;
    
    message->version = 1;
    if (imapMessage->mainPart()) {
        mailcore::Array * htmlParts = mailcore::Array::array();
        mailcore::Array * plainParts = mailcore::Array::array();
        //Note: we can using ONLY one array, indetify them by attachment->isInline & attachment->isAttachment.
        mailcore::Array * attachmentParts = mailcore::Array::array();
        mailcore::Array * inlineAttachmentParts = mailcore::Array::array();
        mailcore::IMAPPartParser::parseMessage(imapMessage, htmlParts, plainParts, attachmentParts, inlineAttachmentParts);
        int index = 0;
        for (int i = 0; i  < htmlParts->count(); i++) {
            mailcore::AbstractPart * part = (mailcore::AbstractPart*)htmlParts->objectAtIndex(i);
            index++;
            addSinglePart(message, index, part, 2, 0);
        }
        for (int i = 0; i  < plainParts->count(); i++) {
            mailcore::AbstractPart * part = (mailcore::AbstractPart*)plainParts->objectAtIndex(i);
            index++;
            addSinglePart(message, index, part, 1, 0);
        }
        for (int i = 0; i  < attachmentParts->count(); i++) {
            mailcore::AbstractPart * part = (mailcore::AbstractPart*)attachmentParts->objectAtIndex(i);
            index++;
            addSinglePart(message, index, part, 0, 2);
        }
        for (int i = 0; i  < inlineAttachmentParts->count(); i++) {
            mailcore::AbstractPart * part = (mailcore::AbstractPart*)inlineAttachmentParts->objectAtIndex(i);
            index++;
            addSinglePart(message, index, part, 0, 1);
        }
        // The following lines are just for testing.
//        std::cout<<"=====>"<<message->subject<<std::endl;
        mailcore::Array * bentchmark1 = mailcore::HTMLRenderer::attachmentsForMessage(imapMessage);
        mailcore::Array * bentchmark2 = mailcore::HTMLRenderer::htmlInlineAttachmentsForMessage(imapMessage);
        mailcore::Array * bentchmark3 =mailcore::HTMLRenderer::requiredPartsForRendering(imapMessage);
//        std::cout<<"attachment:"<<bentchmark1->count()<<";inline:"<<bentchmark2->count()<<";required:"<<bentchmark3->count()<<std::endl;
//        std::cout<<"attachment:"<<attachmentParts->count()<<";inline:"<<inlineAttachmentParts->count()<<";required:"<<htmlParts->count()<<std::endl;
//        std::cout<<"========="<<std::endl;
    }
    
//    EdiMessageUtils::checkPrimary(account, folder, message);
//#if JIRA_CATEGORY_SUPPORTED
//    EdiMessageUtils::checkJIRA(account, folder, message);
//#endif
//
//#if ZENDESK_CATEGORY_SUPPORTED
//    EdiMessageUtils::checkZendesk(account, folder, message);
//#endif
    
    return message;
}

void testMessageParser::parseMessageFromLocalPath(mailcore::String * inputPath) {
    
    Array * list = pathsInDirectory(inputPath);
    EXPECT_GT(list->count(), 0);
    
    mc_foreacharray(String, filename, list) {
        testMessageParser::parseMessageFromLocalFile(filename);
    }
}

EdiTestCheckResult testMessageParser::parseMessageFromLocalFile(mailcore::String * filename) {
    
    EXPECT_FALSE(filename == NULL);
    EdiTestCheckResult result;
    MessageParser * parser = MessageParser::messageParserWithContentsOfFile(filename);
    EXPECT_FALSE(parser == NULL) << MCUTF8(filename);
    if (parser == NULL) {
        printf("testMessageParser: failed for %s\n", MCUTF8(filename));
    }
    mailcore::MessageHeader* header = (mailcore::MessageHeader*)parser->header();
    EXPECT_FALSE(header == NULL);
    if (header) {
        mailcore::String * subject = header->subject();
        if (subject) {
            result.subject = subject->UTF8Characters();
        }
        
        result.recvDate = header->receivedDate();

        mailcore::Address * from = header->from();
        if (from) {
            result.from = from->mailbox()->UTF8Characters();
        }

        mailcore::Array * to = header->to();
        if (to) {
            result.toCount = to->count();
        }

        mailcore::Array * cc = header->cc();
        if (cc) {
            result.ccCount = cc->count();
        }

        mailcore::Array * bcc = header->bcc();
        if (bcc) {
            result.bccCount = bcc->count();
        }
    }
    
    if (parser->mainPart()) {
        mailcore::Array * htmlParts = mailcore::Array::array();
        mailcore::Array * plainParts = mailcore::Array::array();
        mailcore::Array * attachmentParts = mailcore::Array::array();
        mailcore::Array * inlineAttachmentParts = mailcore::Array::array();
        mailcore::IMAPPartParser::parseMessage(parser, htmlParts, plainParts, attachmentParts, inlineAttachmentParts);
        int index = 0;
        result.htmlParts = htmlParts->count();
        result.plainParts = plainParts->count();
        result.attachmentParts = attachmentParts->count();
        result.inlineAttachmentParts = inlineAttachmentParts->count();
        
        for (int i = 0; i  < htmlParts->count(); i++) {
            mailcore::AbstractPart * part = (mailcore::AbstractPart*)htmlParts->objectAtIndex(i);
            //std::cout << part->partID()->UTF8Characters() << std::endl;
        }
        for (int i = 0; i  < plainParts->count(); i++) {
            mailcore::AbstractPart * part = (mailcore::AbstractPart*)plainParts->objectAtIndex(i);
            //std::cout << part->partID()->UTF8Characters() << std::endl;
        }
        for (int i = 0; i  < attachmentParts->count(); i++) {
            mailcore::AbstractPart * part = (mailcore::AbstractPart*)attachmentParts->objectAtIndex(i);
            //std::cout << part->partID()->UTF8Characters() << std::endl;
        }
        for (int i = 0; i  < inlineAttachmentParts->count(); i++) {
            mailcore::AbstractPart * part = (mailcore::AbstractPart*)inlineAttachmentParts->objectAtIndex(i);
            //std::cout << part->partID()->UTF8Characters() << std::endl;
        }
    }
    return result;
}

testEdiMessage * testMessageParser::parserMessageParserToEdiMessage(MessageParser * parser) {
    EXPECT_FALSE(parser == NULL);
        
    testEdiMessage * message = new testEdiMessage();
    mailcore::MessageHeader* header = (mailcore::MessageHeader*)parser->header();
    EXPECT_FALSE(header == NULL);
    if (header) {
        testMessageParser::parseMessageHeader(header, message);
    } else {
        return NULL;
    }
    if (parser->mainPart()) {
        mailcore::Array * htmlParts = mailcore::Array::array();
        mailcore::Array * plainParts = mailcore::Array::array();
        mailcore::Array * attachmentParts = mailcore::Array::array();
        mailcore::Array * inlineAttachmentParts = mailcore::Array::array();
        mailcore::IMAPPartParser::parseMessage(parser, htmlParts, plainParts, attachmentParts, inlineAttachmentParts);
        int index = 0;
        for (int i = 0; i  < htmlParts->count(); i++) {
            mailcore::AbstractPart * part = (mailcore::AbstractPart*)htmlParts->objectAtIndex(i);
            index++;
            addSinglePart(message, index, part, 2, 0);
        }
        for (int i = 0; i  < plainParts->count(); i++) {
            mailcore::AbstractPart * part = (mailcore::AbstractPart*)plainParts->objectAtIndex(i);
            index++;
            addSinglePart(message, index, part, 1, 0);
        }
        for (int i = 0; i  < attachmentParts->count(); i++) {
            mailcore::AbstractPart * part = (mailcore::AbstractPart*)attachmentParts->objectAtIndex(i);
            index++;
            addSinglePart(message, index, part, 0, 2);
        }
        for (int i = 0; i  < inlineAttachmentParts->count(); i++) {
            mailcore::AbstractPart * part = (mailcore::AbstractPart*)inlineAttachmentParts->objectAtIndex(i);
            index++;
            addSinglePart(message, index, part, 0, 1);
        }
    }
    return message;
}

static void testMessageBuilder(String * path)
{
    printf("testMessageBuilder3\n");
    MessageBuilder * builder = new MessageBuilder();
    builder->header()->setFrom(Address::addressWithRFC822String(MCSTR("Hoà <dinh.viet.hoa@gmail.com>")));
    Array * to = Array::array();
    to->addObject(Address::addressWithRFC822String(MCSTR("Foo Bar <dinh.viet.hoa@gmail.com>")));
    to->addObject(Address::addressWithRFC822String(MCSTR("Other Recipient <another-foobar@to-recipient.org>")));
    builder->header()->setTo(to);
    Array * cc = Array::array();
    cc->addObject(Address::addressWithRFC822String(MCSTR("Carbon Copy <dinh.viet.hoa@gmail.com>")));
    cc->addObject(Address::addressWithRFC822String(MCSTR("Other Recipient <another-foobar@to-recipient.org>")));
    builder->header()->setCc(cc);
    builder->header()->setSubject(MCSTR("testMessageBuilder3"));
    builder->header()->setDate(referenceDate());
    builder->header()->setMessageID(MCSTR("MyMessageID123@mail.gmail.com"));
    builder->setHTMLBody(MCSTR("<html><body><div>This is a HTML content</div><div><img src=\"cid:123\"></div></body></html>"));
    String * attachmentPath = path->stringByAppendingPathComponent(MCSTR("input/photo.jpg"));
    builder->addAttachment(Attachment::attachmentWithContentsOfFile(attachmentPath));
    attachmentPath = path->stringByAppendingPathComponent(MCSTR("input/photo2.jpg"));
    Attachment * attachment = Attachment::attachmentWithContentsOfFile(attachmentPath);
    attachment->setContentID(MCSTR("123"));
    builder->addRelatedAttachment(attachment);
    Array * boundaries = Array::array();
    boundaries->addObject(MCSTR("1"));
    boundaries->addObject(MCSTR("2"));
    boundaries->addObject(MCSTR("3"));
    boundaries->addObject(MCSTR("4"));
    boundaries->addObject(MCSTR("5"));
    builder->setBoundaries(boundaries);
    String * outputPath = path->stringByAppendingPathComponent(MCSTR("builder3.eml"));
    builder->writeToFile(outputPath);
    Data * expectedData = Data::dataWithContentsOfFile(outputPath);
    if (!builder->data()->isEqual(expectedData)) {
        printf("testMessageBuilder3 failed\n");
        fprintf(stderr, "current:\n%s\n", MCUTF8(builder->data()->stringWithCharset("utf-8")));
        fprintf(stderr, "expected:\n%s\n", MCUTF8(expectedData->stringWithCharset("utf-8")));
        return;
    }
    printf("testMessageBuilder3 ok\n");
}

void WriteDataToFile(mailcore::Data * data, const std::string & filename) {
    mailcore::String * mStr = new mailcore::String(filename.c_str());
    data->writeToFile(mStr);
}
